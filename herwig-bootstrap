#!/usr/bin/env python
import subprocess,glob
import sys, os, errno, platform, shutil, ssl

try:
    from urllib.request import Request as Request
    from urllib.request import urlopen as urlopen
    from urllib.error   import URLError as URLError
    from urllib.error   import HTTPError as HTTPError
except ImportError:
    from urllib2 import Request as Request
    from urllib2 import urlopen as urlopen
    from urllib2 import URLError as URLError
    from urllib2 import HTTPError as HTTPError

import tarfile
from optparse import OptionParser, OptionGroup
from optparse import SUPPRESS_HELP as NOHELP
from time import sleep

if platform.system() == 'Darwin':
    default_cc  = os.getenv('CC',  '/usr/bin/clang')
    default_cxx = os.getenv('CXX', '/usr/bin/clang++')
    default_fc  = os.getenv('FC',  '/opt/homebrew/bin/gfortran')
else:
    default_cc  = os.getenv('CC',  'gcc')
    default_cxx = os.getenv('CXX', 'g++')
    default_fc  = os.getenv('FC',  'gfortran')

# from http://stackoverflow.com/a/377028
def which(program):
    import os
    def is_exe(fpath):
        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)

    fpath, fname = os.path.split(program)
    if fpath:
        if is_exe(program):
            return program
    else:
        for path in os.environ["PATH"].split(os.pathsep):
            path = path.strip('"')
            exe_file = os.path.join(path, program)
            if is_exe(exe_file):
                return exe_file

    return None

parser = OptionParser(usage='Usage: %prog [options] DEST_DIR\n'
                            '       %prog --help')

without_helptext = """
can optionally be satisfied with pre-existing installations. Specifying the PATH to an
existing installation will prevent a local build.
Each --with-FOO option has a corresponding --without-FOO,
to disable that package completely.
We can't help with build errors arising from use of --with and --without!
"""

parser_core = OptionGroup(parser,"Override main dependencies",
                          "The main dependencies for Herwig"+without_helptext)

parser_nlo = OptionGroup(parser,"Override NLO dependencies",
                          "The dependencies on NLO providers"+without_helptext)

parser_scm = OptionGroup(parser,"Source code repositories (for developers)",
                          "Some dependencies are also available as "
                          "direct source code checkouts. "
                          "Default repo URLs are already provided, you only "
                          "need to use the --foo-repo= options to change the defaults.")

parser_versions = OptionGroup(parser, "Code versions",
                                "Change the default version of the installation.")

parser_misc = OptionGroup(parser,"Miscellaneous options",
                          "Options for special use cases, not required for a regular build.")

parser.add_option_group(parser_core)
parser.add_option_group(parser_nlo)
parser.add_option_group(parser_versions)
parser.add_option_group(parser_scm)
parser.add_option_group(parser_misc)

# src directory
parser_misc.add_option("--src-dir",
                  metavar='PATH',
                  type='string',
                  default="",
                  dest='src_dir',
                  help='Separate the source/build directory. [DEST_DIR/src]')

# lite optin (build a minimal set of packages)
def lite(option, opt, value, parser):
    non_lite_components = ['vbfnlo', 'madgraph', 'evtgen', 'yoda', 'njet', 'gosam', 'openloops', 'hjets', 'rivet', 'fastjet_contrib', 'pythia', 'thep8i']
    for program in non_lite_components:
        setattr(parser.values, program, False)
    pass

parser_misc.add_option("--lite",action="callback", callback=lite,help='Build the minimal set of packages to run Herwig')

# function to set up the standard flags for a program
def setUpFlags(parser,program,version) :
    parser.add_option("--with-"+program   ,
                      dest=program+'_loc',
                      metavar='PATH',
                      default=None,
                      help="")
    parser.add_option("--without-"+program,
                      action='store_false',
                      dest=program,
                      default=True,
                      help=NOHELP)
    if version:
        parser_versions.add_option("--"+program+"-version",
                          metavar='VER',
                          type='string',
                          default=version,
                          dest=program+"_ver",
                          help="[%default]")
# compiler building
parser.add_option("--build-gcc",
                  action='store_true' ,
                  dest="gcc",
                  default=False,
                  help="Build a local copy of the gcc compilers to use for the rest of bootstrap.")

parser_versions.add_option("--gcc-version",
                  metavar='VER',
                  type='string',
                  default='12.2.0',
                  dest="gcc_ver",
                  help="[%default]")

# C++ 14
parser.add_option("--c++14-flag",
                  metavar="'...'",
                  type='string',
                  dest="cxx14",
                  default='-std=c++14',
                  help="Compiler flag which enables C++14 compatibility. ['%default']")

# gengetopt
parser_misc.add_option("--build-gengetopt",
                      action='store_true' ,
                      dest='gengetopt',
                      default=False,
                      help="Always build a local version of gengetopt instead of automatic detection.")

# flags for boost
setUpFlags(parser_core,"boost","1.80.0")
parser_misc.add_option("--boost-all",
                  action='store_false',
                  dest="boost_minimal",
                  default=True,
                  help='Install all the boost libaries, including those not required by Herwig.')
# flags for gsl
setUpFlags(parser_core,"gsl","2.7")
# flags for fastjet
setUpFlags(parser_core,"fastjet","3.4.0")
# flags for fastjet
setUpFlags(parser_core,"fastjet_contrib","1.050")
# flags for hepmc
setUpFlags(parser_core,"hepmc","3.2.5")
# flags for lhapdf
setUpFlags(parser_core,"lhapdf","6.5.3")
parser_misc.add_option("--add-pdf",
                  metavar='PDF',
                  action='append',
                  dest="pdfs",
                  default=["MMHT2014lo68cl","MMHT2014nlo68cl","CT14lo","CT14nlo"],
                  help='Add a PDF to the defaults %default')

# flags for thep8i
setUpFlags(parser_core, "thep8i", "")
parser_scm.add_option("--thep8i-repo",
                  metavar='URL',
                  type='string',
                  default="https://gitlab.cern.ch/TheP8I/TheP8I.git",
                  dest='thep8i_repo',
                  help='[%default]')

# flags for yoda
setUpFlags(parser_core,"yoda","1.9.8")
parser_scm.add_option("--yoda-git",
                  action='store_true',
                  dest="yoda_git",
                  default=False,
                  help='')
parser_scm.add_option("--yoda-repo",
                  metavar='URL',
                  type='string',
                  default="https://gitlab.com/hepcedar/yoda.git",
                  dest='yoda_repo',
                  help='[%default]')
parser_misc.add_option("--yoda-disable-root",
                  action='store_false',
                  dest='yoda_root',
                  default=True,
                  help='Configure YODA with the --disable-root option.')
# flags for rivet
setUpFlags(parser_core,"rivet","3.1.8")
parser_scm.add_option("--rivet-git",
                  action='store_true',
                  dest="rivet_git",
                  default=False,
                  help='')
parser_scm.add_option("--rivet-repo",
                  metavar='URL',
                  type='string',
                  default="https://gitlab.com/hepcedar/rivet.git",
                  dest='rivet_repo',
                  help='[%default]')
# flags for thepeg
setUpFlags(parser_core,"thepeg","2.3.0")
parser_scm.add_option("--thepeg-hg",
                  action='store_true',
                  dest="thepeg_hg",
                  default=False,
                  help='')
parser_scm.add_option("--thepeg-repo",
                  metavar='URL',
                  type='string',
                  default="https://phab.hepforge.org/source/thepeghg/",
                  dest='thepeg_repo',
                  help='[%default]')

# flags for herwig
setUpFlags(parser_core,"herwig","7.3.0")
parser_scm.add_option("--herwig-hg",
                  action='store_true',
                  dest="herwig_hg",
                  default=False,
                  help='')
parser_scm.add_option("--herwig-repo",
                  metavar='URL',
                  type='string',
                  default="https://phab.hepforge.org/source/herwighg/",
                  dest='herwig_repo',
                  help=' [%default]')
# madgraph
setUpFlags(parser_nlo,"madgraph","3.5.1")
parser_scm.add_option("--madgraph-bzr",
                  action='store_true',
                  dest="madgraph_bzr",
                  default=False,
                  help='')
parser_scm.add_option("--madgraph-repo",
                  metavar='URL',
                  type='string',
                  default="lp:~matchboxteam/mg5amcnlo/matchbox_output",
                  dest='madgraph_repo',
                  help='[%default]')
# flags for njet
setUpFlags(parser_nlo,"njet","2.1.1")
# flags for vbfnlo
setUpFlags(parser_nlo,"vbfnlo","3.0.0beta5")
parser_misc.add_option("--vbfnlo-processes",
                  metavar='PROCS',
                  type='string',
                  default="vbf,hjjj",
                  dest='vbfnlo_processes',
                  help='The processes for VBFNLO [%default]')
parser_scm.add_option("--vbfnlo-git",
                  action='store_true',
                  dest="vbfnlo_git",
                  default=False,
                  help='')
parser_scm.add_option("--vbfnlo-repo",
                  metavar='URL',
                  type='string',
                  default="https://github.com/vbfnlo/vbfnlo.git",
                  dest='vbfnlo_repo',
                  help='[%default]')
# flags for GoSam
setUpFlags(parser_nlo,"gosam","")
# flags for OpenLoops
setUpFlags(parser_nlo,"openloops","2.1.2")
parser_scm.add_option("--openloops-svn",
                  action='store_true',
                  dest="openloops_svn",
                  default=False,
                  help='')
parser_scm.add_option("--openloops-repo",
                  metavar='URL',
                  type='string',
                  default="svn+ssh://phab.hepforge.org/source/openloopssvn/OpenLoops/",
                  dest='openloops_repo',
                  help='[%default]')
parser_misc.add_option("--openloops-processes",
                  metavar='PROCS',
                  type='string',
                  default="ppll",
                  dest='openloops_processes',
                  help='The processes for OpenLoops [%default]')
# flags for hjets
setUpFlags(parser_nlo,"hjets","1.3")
parser_scm.add_option("--hjets-hg",
                  action='store_true',
                  dest="hjets_hg",
                  default=False,
                  help='')
parser_scm.add_option("--hjets-repo",
                  metavar='URL',
                  type='string',
                  default="https://hjets.hepforge.org/hg/hjets",
                  dest='hjets_repo',
                  help='[%default]')

## Dependencies for EvtGen
# pythia
setUpFlags(parser_core,"pythia",None)
# version needs to be held fixed at R01-07-00
setUpFlags(parser_core,"evtgen",None)

# no of cores
try:
    from multiprocessing import cpu_count
    ncore = max(cpu_count()-1, 1)
    del cpu_count
except:
    ncore = 1

parser.add_option("-j",
                  type='int',
                  metavar='N',
                  default=ncore,
                  dest="ncore",
                  help="Use N cores in make -j to speed up compilation. [%default]")

del ncore

# get the options and locations
opts, install_dir = parser.parse_args()

if len(install_dir) != 1:
    parser.print_usage(sys.stderr)
    exit(1)
install_dir = install_dir[0]

# enable C++14
if opts.cxx14 not in default_cxx :
    default_cxx = "%s %s" % (default_cxx, opts.cxx14)

# gengetopt is always needed for Herwig hg build
if opts.herwig_hg and which('gengetopt') is None:
    opts.gengetopt = True

if platform.system() == 'Darwin':
    # problem with dd_real from libqd
    opts.njet = False
    sys.stderr.write("* OS X: disabling NJet (need more dd_real overloads for math.h) *\n")

    if opts.gcc:
        sys.stderr.write("""
*********************************************************
*
* Self-building the compilers is not supported on OS X.
*
* Set FC to a Fortran compiler you have installed from
* another source (e.g. MacPorts, Fink or Homebrew) and
* rerun bootstrap without '--build-gcc'.
*
*********************************************************

""")
        sys.exit(1)

    if default_fc is None:
        sys.stderr.write("""
*********************************************************
*
* Set FC to a Fortran compiler you have installed from
* another source (e.g. MacPorts, Fink or Homebrew).
*
*********************************************************

""")
        sys.exit(1)

if not opts.gcc:
    print ("""
*********************************************************
* Using CC="%s" CXX="%s" FC="%s".
* Set these environment variables to change compilers.
*********************************************************

""" % (default_cc,default_cxx,default_fc))

else:
    print ("""
*********************************************************************
* Using self-installed CC, CXX and FC. To use other compilers,
* remove --build-gcc and optionally set these 3 environment variables.
*********************************************************************

""")

# warnings and checks for python 3
if sys.version_info[0] == 3:
    if opts.madgraph :
        vtemp = opts.madgraph_ver.split(".")
        for i in range(0,len(vtemp)): vtemp[i]=int(vtemp[i])
        if(vtemp[0]==2 and (vtemp[1]<7 or (vtemp[1]==7 and vtemp[2]<3))) :
            print ("Version %s of Madgraph is too old to work with python 3\n" % opts.madgraph_ver)
            print ("Please use at least 2.8.1\n")
            quit()
    if which("cython") is None and which("cython3") is None:
        print (
"""Python 3 install needs cython to rebuild lhapdf, yoda and
   rivet python interfaces
""")
        quit()

    if which("autoreconf") is None:
        print ("Python 3 install needs autoreconf to rebuild lhapdf configure script\n")
        quit()
sleep(1)



# set the base directory
current_dir=os.getcwd()

base_dir=os.path.join(current_dir,install_dir)
if not os.path.isdir(base_dir):
    os.mkdir(base_dir)

opt_dir = os.path.join(base_dir,'opt')
if not os.path.isdir(opt_dir):
    os.mkdir(opt_dir)

if not opts.src_dir:
    src_dir = os.path.join(base_dir,'src')
else:
    src_dir = os.path.join(current_dir,opts.src_dir)
if not os.path.isdir(src_dir):
    os.mkdir(src_dir)

# store the used command line for easy repetition later
current_cmdline = [
    'CC="%s"'  % default_cc,
    'CXX="%s"' % default_cxx,
    'FC="%s"'  % default_fc,
]
current_cmdline += sys.argv

with open(os.path.join(src_dir,'herwig_bootstrap_last_cmd'),'w') as f:
    f.write(' '.join(current_cmdline)+'\n')

del current_cmdline

os.chdir(src_dir)


# set the environment variables
bin_dir = os.path.join(base_dir,'bin')
try:
    os.environ['PATH'] = os.pathsep.join([bin_dir, os.environ['PATH']])
except KeyError:
    os.environ['PATH'] = bin_dir


ld_env_name = 'LD_LIBRARY_PATH' if platform.system() != 'Darwin' else 'DYLD_LIBRARY_PATH'
libpaths = [os.path.join(base_dir,'lib')]
if platform.system() != 'Darwin':
    libpaths.append(os.path.join(base_dir,'lib64'))
lib_dirs = os.pathsep.join(libpaths)
try:
    os.environ[ld_env_name] = os.pathsep.join([lib_dirs, os.environ[ld_env_name]])
except KeyError:
    os.environ[ld_env_name] = lib_dirs

iloc_python=3
try :
    int(sys.version[iloc_python])
    iloc_python+=1
except :
    pass
python_path = os.pathsep.join([os.path.join(base_dir,'lib64','python'+sys.version[:iloc_python],'site-packages'),
                               os.path.join(base_dir,'lib', 'python'+sys.version[:iloc_python],'site-packages'),
                               os.path.join(base_dir,'local', 'lib64', 'python'+sys.version[:iloc_python],'dist-packages'),
                               os.path.join(base_dir,'local', 'lib', 'python'+sys.version[:iloc_python],'dist-packages')])
try:
    os.environ['PYTHONPATH'] = os.pathsep.join([python_path, os.environ['PYTHONPATH']])
except KeyError:
    os.environ['PYTHONPATH'] = python_path


# storage of prefix info for individual packages
class Prefixes(dict):
    # return None instead of raising KeyError for unknown package name
    def __missing__(self, key):
        return None
prefix = Prefixes()

def check_call(arglist):
    print(' '.join(arglist))
    subprocess.check_call(arglist)

# checkout
def checkout( location, base, version, repo, branch, repo_type='hg', revision=None) :
    os.chdir(location)
    if repo_type == 'hg':
        directory=base
        if version:
            directory += "-"+version
        if not os.path.isdir(directory):
            check_call(["hg","clone",repo,directory])
        else:
            check_call(["hg","pull","-R",directory,repo])
        os.chdir(os.path.join(location,directory))
        if revision:
            check_call(["hg","up","-r",revision])
        else:
            check_call(["hg","up",branch])
        if os.access('Makefile',os.R_OK):
            print('Makefile exists, skipping autoreconf')
        else:
            check_call(["autoreconf","-vi"])
    elif repo_type == 'git':
        directory=base
        if version:
            directory += "-"+version
        if not os.path.isdir(directory):
            check_call(["git","clone",repo,directory])
            os.chdir(os.path.join(location,directory))
        else:
            os.chdir(os.path.join(location,directory))
            check_call(["git","pull"])
        if revision:
            check_call(["git","checkout",revision])
        else:
            try :
                check_call(["git","fetch","origin",branch])
            except :
                pass
            check_call(["git","checkout",branch])
        if os.access('Makefile',os.R_OK):
            print('Makefile exists, skipping autoreconf')
        else:
            check_call(["autoreconf","-vi"])
    elif repo_type == "bzr":
        check_call(["bzr","co",repo,base])
    elif repo_type == "svn":
        if revision:
            check_call(["svn","checkout",repo+"/"+branch,base,"-r",revision])
        else:
            check_call(["svn","checkout",repo+"/"+branch,base])
        os.chdir(os.path.join(location,base))
    else:
        sys.stderr.write('Only supports checkout from hg, git, svn or bzr\n')
        exit(1)

def download_only(url_base,tar_name,distinct=False) :
    if os.access(tar_name, os.R_OK):
        print('Found existing %s' % tar_name)
        return

    if distinct:
        program_url = url_base
    else:
        program_url = '%s/%s' % (url_base,tar_name)
    print("Download %s as %s" % (program_url,tar_name))

    req_headers = {
        'User-Agent' : 'herwig-bootstrap',
        'Accept'     : '*/*'
    }
    request = Request(program_url, headers=req_headers)

    def response(request, verify_cert=True):
        """Returns response from urllib, accounting for Python2/3 function
        signatures and recursive attempt without certificate validation"""
        try:
            try:
                context = ssl.create_default_context()
                if not verify_cert:
                    context.check_hostname = False
                    context.verify_mode = ssl.CERT_NONE
                response = urlopen(request, context=context)
            except AttributeError:
                response = urlopen(request)
        except (HTTPError) as e:
            reason = getattr(e, 'reason', '[HTTPError did not provide a reason]')
            sys.stderr.write('Remote server returned error code %s: %s\n' % (e.code, reason))
            exit(1)
        except (URLError) as e:
            sys.stderr.write('Could not reach server: %s\n' % e.reason)
            if verify_cert:
                sys.stderr.write('Trying without certificates\n')
                response = response(request, False)
            else:
                exit(1)
        else:
            return response

    response = response(request)
    with open(tar_name, 'wb') as f:
        f.write(response.read())

def download(url_base,tar_name,args=[],distinct=False) :
    download_only(url_base,tar_name,distinct)
    # tarfile module can't use the 'with' context in Python 2.6
    tar = tarfile.open(tar_name,'r')
    lastfile = tar.getnames()[-1]
    if os.access(lastfile, os.R_OK):
        print('Extracted %s exists already' % lastfile.split('/')[0])
    else:
        print("Extract %s" % tar_name)
        tar.extractall()
    tar.close()


def compile(config_flags=[]) :
    if os.access('Makefile',os.R_OK):
        print('Makefile exists, skipping configure')
    else:
        if not os.access('configure', os.X_OK):
            os.chmod('configure', 0o755)
        flags = ["./configure","--prefix="+base_dir]
        flags += config_flags
        check_call(flags)
    check_call(["make","-s","-j%s" % opts.ncore])

    # TODO ?? skip here if some file already exists in /lib or /bin ??
    check_call(["make","-s","install"])
    os.chdir(src_dir)

def downloadAndCompile(url_base,base_name,suffix,config_flags) :
    download(url_base,base_name+suffix)
    os.chdir(os.path.join(src_dir,base_name))
    compile(config_flags)

def deletelibtool() :
    os.chdir(base_dir)
    for directory in ["lib","lib64","lib32"] :
        full_path = os.path.join(base_dir,directory)
        if os.path.isdir(full_path) :
            check_call(["find",full_path,"-name","*.la","-delete"])

GCC_SUFFIX = '-herwig-%s' % opts.gcc_ver

def unsupported_gcc():
    sys.stderr.write("Unsupported gcc version %s requested.\n" % opts.gcc_ver)
    sys.exit(1)

def patch(project,patchtext):
    os.chdir(os.path.join(src_dir,project))
    print('patching in %s' % os.getcwd())
    try:
        p = subprocess.Popen(['patch','-p1'], stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.PIPE)
        stdout_data, stderr_data = p.communicate(input=patchtext)
        print(stdout_data)
        print(stderr_data)
        if p.returncode != 0:
            sys.stderr.write('patch failed\n')
    except OSError:
        sys.stderr.write('patch failed\n')

def buildgcc() :
    # build gmp with --enable-fat to allow portability
    # --enable-fat currently broken on Mac, see
    # https://gmplib.org/repo/gmp/raw-rev/1fab0adc5ff7
    gmp_fatoption = ['--enable-fat']
    if platform.system() == 'Darwin':
        gmp_fatoption = []
    # build gmp
    if marker_is_missing('gmp'):
        downloadAndCompile('https://gmplib.org/download/gmp',"gmp-6.2.1",".tar.bz2",gmp_fatoption)
        prefix['gmp']=base_dir
        mark_as_done('gmp')
    # build mpfr
    if marker_is_missing('mpfr'):
        downloadAndCompile('http://mpfr.loria.fr/mpfr-4.1.0',"mpfr-4.1.0",".tar.bz2",["--with-gmp="+base_dir])
        prefix['mpfr']=base_dir
        mark_as_done('mpfr')
    # build mpc
    if marker_is_missing('mpc'):
        downloadAndCompile("https://ftpmirror.gnu.org/gnu/mpc","mpc-1.2.1",".tar.gz",["--with-gmp="+base_dir,"--with-mpfr="+base_dir])
        prefix['mpc']=base_dir
        mark_as_done('mpc')
    # gcc
    download('https://ftpmirror.gnu.org/gnu/gcc/gcc-'+opts.gcc_ver,
             "gcc-%s.tar.gz" % opts.gcc_ver)

    os.chdir("gcc-%s" % opts.gcc_ver)

    obj_path=os.path.join(src_dir,"gcc-build")
    if not os.access(obj_path, os.R_OK):
        os.mkdir(obj_path)
        os.chdir(obj_path)
    else:
        os.chdir(obj_path)
        # don't use check_call here, the command may not always complete OK
        subprocess.call(["make","distclean"])
    try:
        gcc_version = list(map(int,opts.gcc_ver.split(".")[:2]))
    except:
        sys.stderr.write('Unknown gcc version format. Expecting "N.N.N".\n')
        exit(1)
    flags=["../gcc-%s/configure" % opts.gcc_ver,
           "--prefix="+base_dir,
           "--program-suffix="+GCC_SUFFIX,
           "--disable-multilib"]
    if gcc_version[0] <= 3:
        unsupported_gcc()
    elif gcc_version[0] >= 4:
        if gcc_version[0] == 4 and gcc_version[1] < 8:
            unsupported_gcc()
        else:
            flags.append("--enable-languages=c,c++,fortran")
            flags.append("--with-gmp="+base_dir)
            flags.append("--with-mpfr="+base_dir)
            flags.append("--with-mpc="+base_dir)

    check_call(flags)
    check_call(["make","-s","-j%s" % opts.ncore])
    check_call(["make","-s","install"])
    deletelibtool()
    os.chdir(src_dir)

def lockfile_path(name,version):
    if version:
        version = '_' + version.replace('.','_')
    path = os.path.join(src_dir,
                        'herwig_bootstrap_%s%s_done' % (name,version))
    return path

def mark_as_done(name,version=''):
    lfpath = lockfile_path(name,version)
    with open(lfpath, 'w') as f:
        f.write('%s\n' % prefix[name])

def build_needed(name,version=''):
    alternate_path = getattr(opts,'%s_loc' % name,False)
    if alternate_path:
        print('Alternative given for ' + name + '.\nUsing ' + alternate_path)
        prefix[name] = alternate_path
        return False
    cmdline_flag_set = getattr(opts,name,False) # default to false if not found

    if cmdline_flag_set:
        return marker_is_missing(name,version)
    else:
        return False

def marker_is_missing(name,version=''):
    lfpath = lockfile_path(name,version)
    try:
        with open(lfpath) as f:
            prefixpath = f.readline().rstrip()
    except EnvironmentError:
        return True
    else:
        print('Marker file for ' + name + version + ' exists in src/, skipping build,')
        print('    using prefix=' + prefixpath)
        prefix[name] = prefixpath
        return False


# download and compile gcc
if build_needed('gcc'):
    buildgcc()
    mark_as_done('gcc')

if opts.gcc:
    default_cc  = os.path.join(bin_dir,'gcc%s' % GCC_SUFFIX)
    default_cxx = os.path.join(bin_dir,'g++%s %s' % (GCC_SUFFIX, opts.cxx14) )
    default_fc  = os.path.join(bin_dir,'gfortran%s' % GCC_SUFFIX)

os.environ['CC']  = default_cc
os.environ['CXX'] = default_cxx
os.environ['FC']  = default_fc
os.environ['F77'] = default_fc

if build_needed('gengetopt'):
    os.chdir(src_dir)
    tmp_ncore=opts.ncore
    opts.ncore=1
    downloadAndCompile("https://ftpmirror.gnu.org/gnu/gengetopt/",
                       "gengetopt-2.22.6",".tar.gz",[])
    opts.ncore=tmp_ncore
    mark_as_done('gengetopt')


# install boost if required
if build_needed('boost'):
    os.chdir(src_dir)
    boost_ver2=opts.boost_ver.replace(".","_")
    boost_base = "boost_"+ boost_ver2
    try :
        download("https://boostorg.jfrog.io/artifactory/main/release/"+opts.boost_ver+"/source",
                 boost_base+".tar.bz2")
    except:
        download("http://sourceforge.net/projects/boost/files/boost/"+opts.boost_ver,
                 boost_base+".tar.bz2")
    os.chdir(os.path.join(src_dir,boost_base))

    # make sure we use our own compiler
    # this works as long as default_cxx is sufficiently gcc-like
    # need to separate out the cxxflag addition
    boost_cxx = ' '.join(default_cxx.split(' ')[:-1])
    boost_cxxflags = opts.cxx14

    with open('tools/build/src/user-config.jam','w') as f:
        f.write('using gcc : : "%s" : <cxxflags>"%s" ;\n'
                  % (boost_cxx, boost_cxxflags))

    if opts.boost_minimal:
        check_call(["./bootstrap.sh","--prefix="+base_dir,'threading=multi',"--with-libraries=filesystem,system,test"])
    else :
        check_call(["./bootstrap.sh","--prefix="+base_dir,'threading=multi'])
    check_call(["./b2","--layout=tagged","install","-j%s" % opts.ncore])
    os.chdir(src_dir)

    # on OS X, write helper script
    if platform.system() == 'Darwin':
        helpername='./boost-osx-path-fix'
        with open(helpername,'w') as f:
            f.write(
"""\
#!/bin/bash
for i in %s/lib*/libboost*.dylib
do
  install_name_tool -id $i $i || true
  if [ $(basename $i) == 'libboost_filesystem-mt.dylib' ]; then
      install_name_tool -change libboost_system-mt.dylib $(dirname $i)/libboost_system-mt.dylib $i || true
  fi
done
""" % base_dir)
        os.chmod(helpername,0o755)
        check_call([helpername])

    prefix['boost']=base_dir
    mark_as_done('boost')


# install gsl if required
if build_needed('gsl'):
    os.chdir(src_dir)
    downloadAndCompile("https://ftpmirror.gnu.org/gnu/gsl",
                       "gsl-"+opts.gsl_ver,".tar.gz",
                       [])
    prefix['gsl']=base_dir
    mark_as_done('gsl')


# install fastjet if required
if build_needed('fastjet'):
    os.chdir(src_dir)
    downloadAndCompile("https://fastjet.fr/repo",
                       "fastjet-"+opts.fastjet_ver,".tar.gz",
                       ["--enable-allcxxplugins","--disable-auto-ptr"])
    prefix['fastjet']=base_dir
    mark_as_done('fastjet')

if build_needed('fastjet_contrib'):
    download("https://fastjet.hepforge.org/contrib/downloads",
             "fjcontrib-"+opts.fastjet_contrib_ver+".tar.gz")
    os.chdir(os.path.join(src_dir,"fjcontrib-"+opts.fastjet_contrib_ver))
    # force use of CXX from configure
    files=glob.glob("*/Makefile")
    files.append("Makefile.in")
    for make in files :
        with open('tmp.tmp','w') as outfile:
            with open(make) as infile:
                for line in infile:
                    if("CXX=" not in line) :
                        outfile.write(line)
        shutil.move('tmp.tmp',make)
    # compile
    compile(["--fastjet-config=%s/bin/fastjet-config" % prefix['fastjet']])
    # rivet needs these options for the install
    os.chdir(os.path.join(src_dir,"fjcontrib-"+opts.fastjet_contrib_ver))
    check_call(["make","fragile-shared-install","-j%s" % opts.ncore])
    os.chdir(src_dir)

    prefix['fastjet_contrib']=base_dir
    mark_as_done('fastjet_contrib')

# install hepmc if needed
if build_needed('hepmc'):
    if opts.hepmc_ver[0]=="2":
        download("https://hepmc.web.cern.ch/hepmc/releases",
                 "hepmc"+opts.hepmc_ver+".tgz")
        try :
            os.chdir(os.path.join(src_dir,"hepmc"+opts.hepmc_ver))
        except :
            os.chdir(os.path.join(src_dir,"HepMC-"+opts.hepmc_ver))
        compile(["--with-momentum=GEV","--with-length=MM"])
    else :
        download("https://gitlab.cern.ch/hepmc/HepMC3/-/archive/"+opts.hepmc_ver,
                 "HepMC3-"+opts.hepmc_ver+".tar.bz2")
        if not os.path.exists(os.path.join(src_dir,"hepmc_build")) :
            os.mkdir(os.path.join(src_dir,"hepmc_build"))
        os.chdir(os.path.join(src_dir,"hepmc_build"))
        args=["cmake",os.path.join(src_dir,"HepMC3-"+opts.hepmc_ver),
              "-DCMAKE_INSTALL_PREFIX="+base_dir,
              "-DHEPMC3_ENABLE_ROOTIO:BOOL=OFF",
              "-DHEPMC3_ENABLE_PYTHON:BOOL=OFF"]
        check_call(args)
        check_call(["make","-j%s" %opts.ncore])
        check_call(["make","install"])
    prefix['hepmc']=base_dir
    mark_as_done('hepmc')
# install lhapdf if needed
if build_needed('lhapdf'):
    os.chdir(src_dir)
    args=[]
    if prefix['boost']:
        args.append("--with-boost="+prefix['boost'])
    downloadAndCompile("https://lhapdf.hepforge.org/downloads",
                 "LHAPDF-"+opts.lhapdf_ver, ".tar.gz",
                 args)
    for pdf in opts.pdfs :
        lhapdftool = os.path.join(bin_dir,'lhapdf')
        check_call([lhapdftool,
                    '--listdir='+os.path.join(base_dir,'share','LHAPDF'),
                    '--pdfdir='+os.path.join(base_dir,'share','LHAPDF'),
                    "install",
                    pdf])

    prefix['lhapdf']=base_dir
    mark_as_done('lhapdf')

if opts.lhapdf:
    os.environ['LHAPATH'] = os.path.join(base_dir,'share','LHAPDF')

# install yoda if needed
if build_needed('yoda'):
    os.chdir(src_dir)
    # from tar ball
    if not opts.yoda_git:
        download("https://yoda.hepforge.org/downloads/",
                 "YODA-"+opts.yoda_ver+".tar.bz2")
        os.chdir(os.path.join(src_dir,"YODA-"+opts.yoda_ver))
    else :
        if opts.yoda_ver :
            if len(opts.yoda_ver)==5:
                branch="yoda-"+opts.yoda_ver
            else :
                branch=opts.yoda_ver
        else :
            branch=""
        checkout(src_dir,"YODA",opts.yoda_ver,opts.yoda_repo,branch,'git')
    if sys.version_info[0] == 3:
        for val in ["pyext/yoda/core.cpp","pyext/yoda/util.cpp"]:
            if os.path.isfile(val) : os.remove(val)

    compile([] if opts.yoda_root else ['--disable-root'])
    prefix['yoda']=base_dir
    mark_as_done('yoda')

# install rivet if needed
if build_needed('rivet'):
    os.chdir(src_dir)
    # from tar ball
    if not opts.rivet_git:
        download("https://rivet.hepforge.org/downloads/",
                 "Rivet-"+opts.rivet_ver+".tar.bz2")
        os.chdir(os.path.join(src_dir,"Rivet-"+opts.rivet_ver))
    else:
        if len(opts.rivet_ver)==5:
            branch="rivet-"+opts.rivet_ver
        else:
            branch=opts.rivet_ver
        checkout(src_dir,"Rivet",opts.rivet_ver,opts.rivet_repo,branch,'git')

    if os.path.exists(base_dir+"/lib64") and os.path.isfile(base_dir+"/lib/libfastjetcontribfragile.so"):
        print("soft linking lib/fastjetcontribfragile.so to lib64")
        os.system("ln -s "+base_dir+"/lib/libfastjetcontribfragile.so "+base_dir+"/lib64/libfastjetcontribfragile.so")

    args = []
    for tool in ['yoda','hepmc','fastjet', 'fastjet_contrib']:
        if prefix[tool]:
            if tool == "hepmc" and opts.hepmc_ver[0]=="3" :
                args.append( "--with-%s3=%s" % (tool,prefix[tool]) )
            elif tool == "fastjet_contrib":
                args.append( "--with-fjcontrib=%s" % (prefix[tool]) )
            else:
                args.append( "--with-%s=%s" % (tool,prefix[tool]) )

    compile(args)
    prefix['rivet']=base_dir
    mark_as_done('rivet')


# install thepeg if needed
if build_needed('thepeg',opts.thepeg_ver):
    os.chdir(src_dir)
    # from tar ball

    if not opts.thepeg_hg:
        download("https://thepeg.hepforge.org/downloads","ThePEG-"+opts.thepeg_ver+".tar.bz2")
        os.chdir(os.path.join(src_dir,"ThePEG-"+opts.thepeg_ver))
    else:
        if len(opts.thepeg_ver)==5:
            branch="release-"+opts.thepeg_ver[:3].replace(".","-")
        else:
            branch=opts.thepeg_ver
        checkout(src_dir,"ThePEG",opts.thepeg_ver,opts.thepeg_repo,branch)

    args=[]
    for tool in ['boost','gsl','rivet','hepmc','fastjet','lhapdf']:
        if prefix[tool]:
            args.append( "--with-%s=%s" % (tool,prefix[tool]) )
            if tool == "hepmc" and opts.hepmc_ver[0]=="3" :
                args.append("--with-hepmcversion=3")
    compile(args)
    prefix['thepeg']=base_dir
    mark_as_done('thepeg',opts.thepeg_ver)

# function to run madgraph
def runMadgraph(mgCommand) :
    with open('proc.dat', 'w') as f:
        f.write(mgCommand)
    mg_exe = os.path.join(prefix['madgraph'],'bin','mg5_aMC')
    try :
        check_call([mg_exe,'proc.dat'])
    except :
        check_call(['python2',mg_exe,'proc.dat'])

# install madgraph
if build_needed('madgraph'):
    os.chdir(src_dir)
    # from tar ball
    if not opts.madgraph_bzr:
        mg_name = "MG5_aMC_v"+opts.madgraph_ver.replace(".","_")
        mg_tar  = "MG5_aMC_v%s" % opts.madgraph_ver

        if sys.version_info[0] == 3 and opts.madgraph_ver == "2.7.3" :
            mg_name +="_py3"
            mg_tar+=".py3"
        mg_tar+=".tar.gz"
        try :
            vSplit=opts.madgraph_ver.split(".")
            mg_loc="https://launchpad.net/mg5amcnlo/%s.0/%s.%s.x/+download" % (vSplit[0],vSplit[0],
                                                                               vSplit[1])
            download(mg_loc,mg_tar)

        except :
            print("Madgraph download form the launchpad failed, trying mirror download")
            download("https://herwig.hepforge.org/downloads/?f=mirror/",mg_tar)

        prefix['madgraph']=os.path.join(opt_dir, mg_name)
        print('mv ' + os.path.join(src_dir, mg_name) + os.path.join(opt_dir, mg_name))
        shutil.move(os.path.join(src_dir, mg_name), os.path.join(opt_dir, mg_name))
        del mg_name
    else :
        checkout(opt_dir,"madgraph",opts.madgraph_ver,opts.madgraph_repo,"",'bzr')
        prefix['madgraph']=os.path.join(opt_dir,"madgraph")

    # temp directory for madgraph
    mg_tmp_dir = os.path.join(prefix['madgraph'],'tmp_hw_bootstrap_test')

    if not os.path.isdir(mg_tmp_dir):
        os.mkdir(mg_tmp_dir)

    os.chdir(mg_tmp_dir)

    # run madgraph so loop stuff is installed
    # and try to automatically convert all python2 models
    # Note: the command "set acknowledged_v3.1_syntax True --global"
    # reverts MG >= 3.2.0 syntax to before 3.1.
    mg_initial_run = """\
set auto_update 0
set cpp_compiler {cxx}
set fortran_compiler {fc}
set auto_convert_model T
set acknowledged_v3.1_syntax True --global
import model sm
generate g g > h > w+ w- [virt=QCD]
output


""".format(cxx=default_cxx,fc=default_fc)

    runMadgraph(mg_initial_run)

    # force import of the heft model
    heftTemplate = """\
set auto_update 0
set cpp_compiler {cxx}
set fortran_compiler {fc}
{convert}
import model heft

"""
    mg_heft = heftTemplate.format(cxx=default_cxx,fc=default_fc,convert="set auto_convert_model T")
    runMadgraph(mg_heft)
    # remove tmp directory
    shutil.rmtree(mg_tmp_dir)

    mark_as_done('madgraph')

# install the NLO codes if needed
# install njet if required
if build_needed('njet'):
    os.chdir(src_dir)
    try:
        download("https://bitbucket.org/njet/njet/downloads",
                 "njet-"+opts.njet_ver+".tar.gz")
    except:
        print("NJet download form the bitbucket.org failed, trying mirror download")
        download("https://herwig.hepforge.org/downloads/?f=mirror/",
                 "njet-"+opts.njet_ver+".tar.gz")
    patch("njet-"+opts.njet_ver,
b"""\
diff blha/njet_olp.cpp
--- a/blha/njet_olp.cpp   2014-04-25 12:38:30.000000000 +0100
+++ b/blha/njet_olp.cpp   2016-11-22 12:44:34.187725299 +0000
@@ -1076,12 +1076,12 @@
   string line;
   int linenum = 0;

-  while (is_good && (is_good = getline(*input, line))) {
+  while (is_good && (is_good = bool(getline(*input, line)))) {
     linenum++;
     if (line.find(SIGNPREF) == 0) {
       is_njet = true;
       if (stringstream(line.substr(SIGNPREF.length())) >> signval) {
-        is_good = getline(*input, line);
+        is_good = bool(getline(*input, line));
         linenum++;
         body.push_back(line);
         continue;
""")
    compile(["--disable-autoflags",
             "FC="+default_fc,
             "F77="+default_fc,
             "FFLAGS=-std=legacy"])
    prefix['njet']=base_dir
    mark_as_done('njet')


OPENLOOPS_CONFIG = """\
[OpenLoops]
fortran_compiler = {fc}
compile_extra = 0
"""

# install openloops if needed
if build_needed('openloops'):
    if not opts.openloops_svn:
        os.chdir(opt_dir)
        download("https://openloops.hepforge.org/downloads","OpenLoops-"+opts.openloops_ver+".tar.gz")
        os.chdir(os.path.join(opt_dir,"OpenLoops-"+opts.openloops_ver))

        with open('openloops.cfg','w') as f:
            f.write(OPENLOOPS_CONFIG.format(fc=default_fc))

        # We know our gcc works. Disable the strange test that uses the system version number.
        if opts.gcc:
            searchtext = "env.subst('$CCVERSION').split('.')[:2])) < (4,6)"
            with open('tmp.tmp','w') as outfile:
                with open('SConstruct') as infile:
                    for line in infile:
                        outfile.write(line.replace(searchtext, searchtext + " and False"))
            shutil.move('tmp.tmp','SConstruct')
            del searchtext
        check_call(["./scons","--jobs=%s" % opts.ncore])
        check_call(["./openloops","libinstall",opts.openloops_processes,
                    "num_jobs=%s" % opts.ncore])
        os.chdir(src_dir)
        prefix['openloops']=opt_dir+"/OpenLoops-"+opts.openloops_ver
        mark_as_done('openloops')
    else:
        checkout(opt_dir,"OpenLoops",opts.openloops_ver,opts.openloops_repo,opts.openloops_ver,'svn',
                 revision='1945')

        with open('openloops.cfg','w') as f:
            f.write(OPENLOOPS_CONFIG.format(fc=default_fc))

        # We know our gcc works. Disable the strange test that uses the system version number.
        if opts.gcc:
            searchtext = "env.subst('$CCVERSION').split('.')[:2])) < (4,6)"
            with open('tmp.tmp','w') as outfile:
                with open('SConstruct') as infile:
                    for line in infile:
                        outfile.write(line.replace(searchtext, searchtext + " and False"))
            shutil.move('tmp.tmp','SConstruct')
            del searchtext

        check_call(["./openloops","libinstall",opts.openloops_processes,
                    "num_jobs=%s" % opts.ncore])
        os.chdir(src_dir)
        prefix['openloops']=opt_dir+"/OpenLoops"
        mark_as_done('openloops')


# install gosam if needed
if build_needed('gosam'):
    os.chdir(src_dir)
    # build qgraf
    if marker_is_missing('qgraf'):
        download("https://herwig.hepforge.org/downloads/mirror","qgraf-3.4.2.tgz")
        os.chdir(os.path.join(src_dir,'qgraf-3.4.2'))
        check_call([default_fc,'qgraf-3.4.2.f','-o','qgraf','-O2'])
        shutil.move('qgraf',os.path.join(bin_dir,'qgraf'))
        prefix['qgraf']=base_dir
        os.chdir(src_dir)
        mark_as_done('qgraf')
    # build form
    if marker_is_missing('form'):
        download("https://github.com/vermaseren/form/releases/download/v4.2.1","form-4.2.1.tar.gz")
        os.chdir(os.path.join(src_dir,'form-4.2.1'))
        compile([])
        prefix['form']=base_dir
        mark_as_done('form')
    # build gosam-contrib
    if marker_is_missing('gosam-contrib'):
        download('https://github.com/gudrunhe/gosam-contrib/releases/download/gosam-contrib-2.0-20200904/gosam-contrib-2.0-20200904.tar.gz',
                 "gosam-contrib-2.0.tar.gz", distinct=True)
        os.chdir(os.path.join(src_dir,'gosam-contrib-2.0'))
        # Gosams build system sometimes hangs and needs a second trial
        try:
          compile(["FFLAGS=-std=legacy"])
        except subprocess.CalledProcessError:
          compile(["FFLAGS=-std=legacy"])
        prefix['gosam-contrib']=base_dir
        mark_as_done('gosam-contrib')

    download('https://github.com/gudrunhe/gosam/releases/download/2.1.1/gosam-2.1.1-4b98559.tar.gz','gosam-2.1.1.tar.gz', distinct=True)
    try:
        os.chdir(os.path.join(src_dir,'gosam-2.1.1-4b98559'))
    except OSError:
        os.chdir(os.path.join(src_dir,'gosam'))

    check_call(["./setup.py",
                "install",
                "--prefix="+base_dir,
                "-f"])
    os.chdir(src_dir)
    prefix['gosam']=base_dir
    mark_as_done('gosam')


# install vbfnlo if required
if build_needed('vbfnlo'):
    os.chdir(src_dir)
    # from tar ball
    if not opts.vbfnlo_git:
        download("https://www.itp.kit.edu/vbfnlo/archive","vbfnlo-"+opts.vbfnlo_ver+".tgz")
        os.chdir(os.path.join(src_dir,"VBFNLO-"+opts.vbfnlo_ver))
    else:
        checkout(src_dir,"VBFNLO",opts.vbfnlo_ver,opts.vbfnlo_repo,"v"+opts.vbfnlo_ver,'git')
    if opts.vbfnlo_ver == "3.0.0beta1" or opts.vbfnlo_ver == "3.0.0beta2":
        # 3.0.0beta1 and 2 did not yet accept setting F77
        del os.environ['F77']
    check_call(["./configure","--prefix="+base_dir,"--enable-processes="+opts.vbfnlo_processes,
                "FCFLAGS=-std=legacy"])
    check_call(["make","-s","-j%s"%opts.ncore])
    check_call(["make","-s","install"])
    if opts.vbfnlo_ver == "3.0.0beta1" or opts.vbfnlo_ver == "3.0.0beta2":
        # reinsert F77 for the others
        os.environ['F77'] = default_fc
    os.chdir(src_dir)
    prefix['vbfnlo']=base_dir
    mark_as_done('vbfnlo')

# # install TAUOLA if needed
# if build_needed('tauola'):
#     download("http://tauolapp.web.cern.ch/tauolapp/resources/TAUOLA." + opts.tauola_ver,
#              "TAUOLA." + opts.tauola_ver + ".tar.gz")
#     os.chdir(os.path.join(src_dir,"TAUOLA"))
#     args=["./configure","--prefix="+base_dir]
#     if prefix['hepmc']:
#         args.append("--with-hepmc="+prefix['hepmc'])
#     check_call(args)
#     check_call(["make"])
#     check_call(["make","install"])
#     os.chdir(src_dir)
#     prefix['tauola']=base_dir
#     mark_as_done('tauola')

# # install PHOTOS if needed
# if build_needed('photos'):
#     download("http://photospp.web.cern.ch/photospp/resources/PHOTOS."+opts.photos_ver,
#              "PHOTOS."+opts.photos_ver+".tar.gz")
#     os.chdir(os.path.join(src_dir,"PHOTOS"))
#     args=["./configure","--prefix="+base_dir]
#     if prefix['hepmc']:
#         args.append("--with-hepmc="+prefix['hepmc'])
#     check_call(args)
#     check_call(["make","-j%s" % opts.ncore])
#     check_call(["make","install"])
#     os.chdir(src_dir)
#     prefix['photos']=base_dir
#     mark_as_done('photos')

# install Pytiha8 if needed
if build_needed('pythia'):
    os.chdir(src_dir)
    pythia_version = "8.308".replace(".","")
    download("https://pythia.org/download/pythia83","pythia%s.tgz" % pythia_version)
    os.chdir(os.path.join(src_dir,"pythia%s" % pythia_version))
    args=["./configure",
          "--prefix=%s" % base_dir,
          "--enable-shared",]
### newer versions need this instead of USRCXXFLAGS
###           "--cxx-common='-O2 -pedantic -W -Wall -Wshadow'"]
    if prefix['hepmc']:
        if opts.hepmc_ver[0]=="2" :
            args.append("--with-hepmc2=%s" % prefix['hepmc'])
        else :
            args.append("--with-hepmc3=%s" % prefix['hepmc'])
    os.environ['USRCXXFLAGS'] = opts.cxx14
    check_call(args)
    check_call(["make","-j%s" % opts.ncore])
    check_call(["make","-s","install"])
    del os.environ['USRCXXFLAGS']
    os.chdir(src_dir)
    prefix['pythia'] = base_dir
    mark_as_done('pythia')

# install EvtGen if needed
if build_needed('evtgen'):
    os.chdir(src_dir)
    evtgen_version = '02.02.00'
    evtgen_srcpath = os.path.join('EvtGen', 'R'+evtgen_version.replace('.','-'))
    download("https://evtgen.hepforge.org/downloads",
             "EvtGen-%s.tar.gz" % evtgen_version)
    patch(evtgen_srcpath,
b"""\
diff DECAY_2010.DEC
--- a/DECAY_2010.DEC
+++ b/DECAY_2010.DEC
@@ -204,7 +204,7 @@
 #####JetSetPar PARJ(33)=0.3 SET NOW IN GAUSS

 # PR LHCb 10/01/2006
 # Turn on PHOTOS for all decays
-yesPhotos
+noPhotos
 #
 #
 #Decay vpho
""")
    if not os.path.exists(os.path.join(src_dir,"EvtGen/evtgen_build")) :
        os.mkdir(os.path.join(src_dir,"EvtGen/evtgen_build"))
    os.chdir(os.path.join(src_dir,"EvtGen/evtgen_build"))

    args=["cmake",os.path.join(src_dir,evtgen_srcpath),"-DCMAKE_INSTALL_PREFIX="+base_dir]
    if prefix['hepmc'] and opts.hepmc_ver[0]=="2":
        args.append("-DEVTGEN_HEPMC3=OFF")
        args.append("-DHEPMC2_ROOT_DIR="+prefix['hepmc'])
    # if prefix['tauola']:
    #     args.append("--tauoladir="+prefix['tauola'])
    # if prefix['photos']:
    #     args.append("--photosdir="+prefix['photos'])
    if prefix['pythia']:
        args.append("-DEVTGEN_PYTHIA=ON")
        args.append("-DPYTHIA8_ROOT_DIR="+prefix['pythia'])
    check_call(args)
    # Has to be single thread build. Dependencies are broken otherwise.
    check_call(["make","-j1"])
    check_call(["make","install"])
    if platform.system() == 'Darwin':
        # fix path settings to help autodetection of lib locations
        os.chdir(os.path.join(base_dir,'lib'))
        for i in ["libEvtGen.dylib", "libEvtGenExternal.dylib"]:
            check_call(["install_name_tool","-id",os.path.join(os.getcwd(),i),i])
        for i in ["libEvtGen.dylib","libpythia8.dylib","liblhapdfdummy.dylib"]:
            check_call(["install_name_tool","-change",i,os.path.join(os.getcwd(),i),"libEvtGenExternal.dylib"])

    os.chdir(src_dir)
    prefix['evtgen']=base_dir
    mark_as_done('evtgen')

# install herwig if needed
if build_needed('herwig',opts.herwig_ver):
    os.chdir(src_dir)
    # from tar ball
    if not opts.herwig_hg:
        download("https://herwig.hepforge.org/downloads/","Herwig-"+opts.herwig_ver+".tar.bz2")
        os.chdir(os.path.join(src_dir,"Herwig-"+opts.herwig_ver))
    else:
        if len(opts.herwig_ver)==5:
            branch = "herwig-"+opts.herwig_ver[:3].replace(".","-")
        else:
            branch = opts.herwig_ver
        checkout(src_dir,"Herwig",opts.herwig_ver,opts.herwig_repo,branch)
    args=[]
    for tool in ['thepeg','boost','gsl','fastjet',
                 'madgraph','njet','openloops','gosam','vbfnlo',
                 'pythia','evtgen']:
        if prefix[tool]:
            args.append( "--with-%s=%s" % (tool,prefix[tool]) )
    compile(args)
    prefix['herwig']=base_dir
    mark_as_done('herwig',opts.herwig_ver)

# install TheP8I if needed
if build_needed('thep8i'):
    #test_dir="/home/pratixan/Work_Dir/MAP/Herwig+P8I/Herwig-7.3_test"
    branch="master"
    checkout(src_dir,"TheP8I","",opts.thep8i_repo,branch,'git')
    patch("TheP8I",
b"""\
diff configure.ac
--- a/configure.ac      2024-06-19 23:01:58.629664006 +0200
+++ b/configure.ac      2024-06-19 23:00:26.239679450 +0200
@@ -78,15 +78,14 @@

 PYTHIA8_VERSION=` grep -oP '[[0-9]][[.]]([[0-9]]+)' $PYTHIA8_XMLDIR/Version.xml`
 PYTHIA8_VERSION_INTEGER=` grep -oP '[[0-9]][[.]]([[0-9]]+)'  $PYTHIA8_XMLDIR/Version.xml | tr -d .`
-if [[ "$PYTHIA8_VERSION_INTEGER" -gt "8306" ]]; then
+if [[ "$PYTHIA8_VERSION_INTEGER" -lt "8308" ]]; then
+AC_MSG_ERROR([WARNING: TheP8I requires Pythai8 version > 8307 for installation.])
+fi
 LDFLAGS="$LDFLAGS  -pthread"
 PYTHIA8_CPPFLAGS="$PYTHIA8_CPPFLAGS  -pthread"
 echo "Threading is required for Pythia8 version $PYTHIA8_VERSION_INTEGER"
 echo "LDFLAGS=$LDFLAGS"
 echo "PYTHIA8_CPPFLAGS=$PYTHIA8_CPPFLAGS"
-else
-echo "No threading is required for Pythia8 version $PYTHIA8_VERSION_INTEGER"
-fi
 save_LDFLAGS="$LDFLAGS"
 save_LIBS="$LIBS"
 save_CPPFLAGS="$CPPFLAGS"
diff include/TheP8I/Hadronization/ColourReconnection-init.h
--- a/include/TheP8I/Hadronization/ColourReconnection-init.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/TheP8I/Hadronization/ColourReconnection-init.h	2024-06-05 16:33:45.760474238 +0100
@@ -0,0 +1,17 @@
+    CR_reconnect(0),
+    CR_mode(1),
+    CR_m0(0.3),
+    CR_junctionCorrection(1.2),
+    CR_nColours(9),
+    CR_sameNeighbourColours(0),
+    CR_allowJunctions(1),
+    CR_lambdaForm(0),
+    CR_allowDoubleJunRem(1),
+    CR_timeDilationMode(2),
+    CR_timeDilationPar(0.18),
+    CR_m2Lambda(1.0),
+    CR_fracGluon(1.0),
+    CR_dLambdaCut(0.0),
+    CR_flipMode(0),
+    CR_forceHadronLevel(0),
+    BR_remnantMode(0),
diff include/TheP8I/Hadronization/ColourReconnection-input.h
--- a/include/TheP8I/Hadronization/ColourReconnection-input.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/TheP8I/Hadronization/ColourReconnection-input.h	2024-06-05 16:33:45.760474238 +0100
@@ -0,0 +1,17 @@
+    >> CR_reconnect
+    >> CR_mode
+    >> CR_m0
+    >> CR_junctionCorrection
+    >> CR_nColours
+    >> CR_sameNeighbourColours
+    >> CR_allowJunctions
+    >> CR_lambdaForm
+    >> CR_allowDoubleJunRem
+    >> CR_timeDilationMode
+    >> CR_timeDilationPar
+    >> CR_m2Lambda
+    >> CR_fracGluon
+    >> CR_dLambdaCut
+    >> CR_flipMode
+    >> CR_forceHadronLevel
+    >> BR_remnantMode
diff include/TheP8I/Hadronization/ColourReconnection-interfaces.h
--- a/include/TheP8I/Hadronization/ColourReconnection-interfaces.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/TheP8I/Hadronization/ColourReconnection-interfaces.h	2024-06-05 16:33:45.760474238 +0100
@@ -0,0 +1,101 @@
+static Parameter<StringFragmentation,int> interfaceCR_reconnect
+  ("CRreconnect",
+   "  Colour Reconnection reconnet parameter.  ",
+   &StringFragmentation::CR_reconnect, 0, 0, 1,
+   true, false, Interface::limited);
+
+static Parameter<StringFragmentation,int> interfaceCR_mode
+  ("CRmode",
+   "  Colour Reconnection mode parameter.  ",
+   &StringFragmentation::CR_mode, 1, 0, 4,
+   true, false, Interface::limited);
+
+static Parameter<StringFragmentation,double> interfaceCR_m0
+  ("CRm0",
+   " QCD Colour Reconnection m0 parameter.  ",
+   &StringFragmentation::CR_m0, 0.3, 0.1, 5.0,
+   true, false, Interface::limited);
+
+static Parameter<StringFragmentation,double> interfaceCR_junctionCorrection
+  ("CRjunctionCorrection",
+   " QCD Colour Reconnection junctionCorrection parameter.  ",
+   &StringFragmentation::CR_junctionCorrection, 1.2, 0.01, 10.0,
+   true, false, Interface::limited);
+
+static Parameter<StringFragmentation,int> interfaceCR_nColours
+  ("CRnColours",
+   " QCD Colour Reconnection nColours mode.  ",
+   &StringFragmentation::CR_nColours, 9, 1, 30,
+   true, false, Interface::limited);
+
+static Parameter<StringFragmentation,int> interfaceCR_sameNeighbourColours
+  ("CRsameNeighbourColours",
+   " QCD Colour Reconnection sameNeighbourColours flag.  ",
+   &StringFragmentation::CR_sameNeighbourColours, 0, 0, 1,
+   true, false, Interface::limited);
+
+static Parameter<StringFragmentation,int> interfaceCR_allowJunctions
+  ("CRallowJunctions",
+   " QCD Colour Reconnection allowJunctions flag.  ",
+   &StringFragmentation::CR_allowJunctions, 1, 0, 1,
+   true, false, Interface::limited);
+
+static Parameter<StringFragmentation,int> interfaceCR_lambdaForm
+  ("CRlambdaForm",
+   " QCD Colour Reconnection lambdaForm mode.  ",
+   &StringFragmentation::CR_lambdaForm, 0, 0, 2,
+   true, false, Interface::limited);
+
+static Parameter<StringFragmentation,int> interfaceCR_allowDoubleJunRem
+  ("CRallowDoubleJunRem",
+   " QCD Colour Reconnection allowDoubleJunRem flag.  ",
+   &StringFragmentation::CR_allowDoubleJunRem, 1, 0, 1,
+   true, false, Interface::limited);
+
+static Parameter<StringFragmentation,int> interfaceCR_timeDilationMode
+  ("CRtimeDilationMode",
+   " QCD Colour Reconnection timeDilationMode mode.  ",
+   &StringFragmentation::CR_timeDilationMode, 2, 0, 5,
+   true, false, Interface::limited);
+
+static Parameter<StringFragmentation,double> interfaceCR_timeDilationPar
+  ("CRtimeDilationPar",
+   " QCD Colour Reconnection timeDilationPar parameter.  ",
+   &StringFragmentation::CR_timeDilationPar, 0.18, 0.0, 100.0,
+   true, false, Interface::limited);
+
+static Parameter<StringFragmentation,double> interfaceCR_m2Lambda
+  ("CRm2Lambda",
+   "  Colour Reconnection m2Lambda parameter.  ",
+   &StringFragmentation::CR_m2Lambda, 1.0, 0.25, 16.0,
+   true, false, Interface::limited);
+
+static Parameter<StringFragmentation,double> interfaceCR_fracGluon
+  ("CRfracGluon",
+   "  Colour Reconnection fracGluon parameter.  ",
+   &StringFragmentation::CR_fracGluon, 1.0, 0.0, 1.0,
+   true, false, Interface::limited);
+
+static Parameter<StringFragmentation,double> interfaceCR_dLambdaCut
+  ("CRdLambdaCut",
+   "  Colour Reconnection dLambdaCut parameter.  ",
+   &StringFragmentation::CR_dLambdaCut, 0.0, 0.0, 10.0,
+   true, false, Interface::limited);
+
+static Parameter<StringFragmentation,int> interfaceCR_flipMode
+  ("CRflipMode",
+   "  Colour Reconnection flipMode parameter.  ",
+   &StringFragmentation::CR_flipMode, 0, 0, 4,
+   true, false, Interface::limited);
+
+static Parameter<StringFragmentation,int> interfaceCR_forceHadronLevel
+  ("CRforceHadronLevel",
+   "  Colour Reconnection forceHadronLevelCR parameter.  ",
+   &StringFragmentation::CR_forceHadronLevel, 1, 0, 1,
+   true, false, Interface::limited);
+
+static Parameter<StringFragmentation,int> interfaceBR_remnantMode
+  ("BRremnantMode",
+   "  Beam Remnants remnantMode mode.  ",
+   &StringFragmentation::BR_remnantMode, 0, 0, 1,
+   true, false, Interface::limited);
diff include/TheP8I/Hadronization/ColourReconnection-output.h
--- a/include/TheP8I/Hadronization/ColourReconnection-output.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/TheP8I/Hadronization/ColourReconnection-output.h	2024-06-05 16:33:45.760474238 +0100
@@ -0,0 +1,17 @@
+    << CR_reconnect
+    << CR_mode
+    << CR_m0
+    << CR_junctionCorrection
+    << CR_nColours
+    << CR_sameNeighbourColours
+    << CR_allowJunctions
+    << CR_lambdaForm
+    << CR_allowDoubleJunRem
+    << CR_timeDilationMode
+    << CR_timeDilationPar
+    << CR_m2Lambda
+    << CR_fracGluon
+    << CR_dLambdaCut
+    << CR_flipMode
+    << CR_forceHadronLevel
+    << BR_remnantMode
diff include/TheP8I/Hadronization/StringFragmentation.h
--- a/include/TheP8I/Hadronization/StringFragmentation.h	2024-06-05 16:25:33.790731430 +0100
+++ b/include/TheP8I/Hadronization/StringFragmentation.h	2024-06-05 16:33:33.750484886 +0100
@@ -298,6 +298,45 @@
     // Keep track of how many events we already hadronized using this object, in order to clean up
     int nev;

+    /**
+     * Colour Reconnection parameters
+     */
+    int CR_reconnect;
+
+    int CR_mode;
+
+    // CR mode = 1 parameters
+    double CR_m0;
+
+    double CR_junctionCorrection;
+
+    int CR_nColours;
+
+    int CR_sameNeighbourColours;
+
+    int CR_allowJunctions;
+
+    int CR_lambdaForm;
+
+    int CR_allowDoubleJunRem;
+
+    int CR_timeDilationMode;
+
+    double CR_timeDilationPar;
+
+    // CR mode = 2 parameters
+    double CR_m2Lambda;
+
+    double CR_fracGluon;
+
+    double CR_dLambdaCut;
+
+    int CR_flipMode;
+
+    int CR_forceHadronLevel;
+
+    int BR_remnantMode;
+
     void dofinish();

     // Can print the strings of the event in a matlab friendly format
diff src/Hadronization/StringFragmentation.cc
--- a/src/Hadronization/StringFragmentation.cc	2024-06-05 16:25:33.790731430 +0100
+++ b/src/Hadronization/StringFragmentation.cc	2024-06-05 16:33:14.780490216 +0100
@@ -35,6 +35,7 @@
        throwaway(false), shoving(false), deltay(5.0), tshove(1.0*femtometer),
        deltat(0.1*femtometer), rCutOff(4.0), gAmplitude(1.0*GeV/femtometer), gExponent(1.0), yCutOff(4.0), lorentz(true), cylinder(false),
        opHandler(0), maxTries(2),
+#include "ColourReconnection-init.h"
 #include "StringFragmentation-init.h"
 {
 }
@@ -631,6 +632,30 @@
                                convert(fragmentationMass));
         moresettings.push_back("OverlapStrings:baryonSuppression = " + convert(baryonSuppression));

+	//Colour Reconnection parameters
+	moresettings.push_back("ColourReconnection:reconnect = "+ convert(CR_reconnect));
+	moresettings.push_back("ColourReconnection:mode = "+ convert(CR_mode));
+
+	//CR  mode = 1 additional settings:
+	moresettings.push_back("ColourReconnection:m0 = "+ convert(CR_m0));
+	moresettings.push_back("ColourReconnection:junctionCorrection = "+ convert(CR_junctionCorrection));
+	moresettings.push_back("ColourReconnection:nColours = "+ convert(CR_nColours));
+	moresettings.push_back("ColourReconnection:sameNeighbourColours = "+ convert(CR_sameNeighbourColours));
+	moresettings.push_back("ColourReconnection:allowJunctions = "+ convert(CR_allowJunctions));
+	moresettings.push_back("ColourReconnection:lambdaForm = "+ convert(CR_lambdaForm));
+	moresettings.push_back("ColourReconnection:allowDoubleJunRem = "+ convert(CR_allowDoubleJunRem));
+	moresettings.push_back("ColourReconnection:timeDilationMode = "+ convert(CR_timeDilationMode));
+	moresettings.push_back("ColourReconnection:timeDilationPar = "+ convert(CR_timeDilationPar));
+
+	moresettings.push_back("ColourReconnection:forceHadronLevelCR = "+ convert(CR_forceHadronLevel)); //0,1
+	moresettings.push_back("BeamRemnants:remnantMode = "+ convert(BR_remnantMode)); //0,1
+
+	//CR  mode = 2 additional settings:
+	moresettings.push_back("ColourReconnection:m2Lambda = "+ convert(CR_m2Lambda));//0.25 - 16.
+	moresettings.push_back("ColourReconnection:fracGluon = "+ convert(CR_fracGluon));//0.0 - 1.0
+	moresettings.push_back("ColourReconnection:dLambdaCut = "+ convert(CR_dLambdaCut));//0.0 - 10.
+	moresettings.push_back("ColourReconnection:flipMode = "+ convert(CR_flipMode)); //0,1,2,3,4
+
         // Initialize the OverlapPythia Handler
         if ( opHandler ) delete opHandler;
         opHandler = new OverlapPythiaHandler(this,moresettings);
@@ -642,6 +667,7 @@

 void StringFragmentation::persistentOutput(PersistentOStream & os) const {
     os
+#include "ColourReconnection-output.h"
 #include "StringFragmentation-output.h"
             << fScheme << ounit(stringR0,femtometer) << ounit(stringm0,GeV) << junctionDiquark << alpha << average << stringyCut
             << ounit(stringpTCut,GeV) << fragmentationMass << baryonSuppression
@@ -652,6 +678,7 @@

 void StringFragmentation::persistentInput(PersistentIStream & is, int) {
     is
+#include "ColourReconnection-input.h"
 #include "StringFragmentation-input.h"
             >> fScheme >> iunit(stringR0,femtometer) >> iunit(stringm0,GeV) >> junctionDiquark >> alpha >> average >> stringyCut
             >> iunit(stringpTCut,GeV) >> fragmentationMass >> baryonSuppression
@@ -664,6 +691,7 @@
 // Definition of the static class description member.

 void StringFragmentation::Init() {
+#include "ColourReconnection-interfaces.h"
 #include "StringFragmentation-interfaces.h"
     static Reference<StringFragmentation,ClusterCollapser> interfaceCollapser
     ("Collapser",

""")
    args=["./configure",
          "--prefix=%s" % base_dir,
          "--with-pythia8=%s" % base_dir,
          "THEPEGPATH=%s" % base_dir]

    check_call(args)
    check_call(["make","-j%s" % opts.ncore])
    check_call(["make","-s","install"])
    os.chdir(src_dir)

    prefix['thep8i']=base_dir
    mark_as_done('thep8i')


# need to have Herwig if we want HJets++
if not opts.herwig:
    opts.hjets = False

# install hjets if needed
if build_needed('hjets'):
    os.chdir(src_dir)
    # from tar ball
    if not opts.hjets_hg:
        download("http://www.hepforge.org/archive/hjets",
                 "HJets-"+opts.hjets_ver+".tar.bz2")
        os.chdir(os.path.join(src_dir,"HJets-"+opts.hjets_ver))
    else :
        if len(opts.hjets_ver)==3:
            branch = "release "+opts.hjets_ver
        else:
            branch = opts.hjets_ver
        checkout(src_dir,"HJets",opts.hjets_ver,opts.hjets_repo,branch)
    args=[]
    args.append("--with-herwig="+prefix['herwig'])
    del os.environ['F77']
    compile(args)
    os.environ['F77'] = default_fc
    prefix['hjets']=base_dir
    lib_dirs = os.pathsep.join([os.path.join(prefix['hjets'], 'lib64','HJets'),
                                os.path.join(prefix['hjets'], 'lib','HJets'),
                                lib_dirs])
    mark_as_done('hjets')

# generate an 'activate' shell include like python's virtualenv does
from string import Template

class ShellTemplate(Template):
    delimiter = '@'

ACTIVATE = ShellTemplate("""\
# Herwig bootstrap 'activate',
# based on Python's virtualenv mechanism

# This file must be used with "source @{bin_dir}/activate"
# *from bash or zsh*. You cannot run it directly.

deactivate () {

    # reset old environment variables
    if [ "${_OLD_VIRTUAL_PATH-}" = "Unset" ] ; then
        unset PATH
        unset _OLD_VIRTUAL_PATH
    elif [ -n "${_OLD_VIRTUAL_PATH-}" ] ; then
        PATH="$_OLD_VIRTUAL_PATH"
        export PATH
        unset _OLD_VIRTUAL_PATH
    fi

    if [ "${_OLD_VIRTUAL_PYTHONPATH-}" = "Unset" ] ; then
        unset PYTHONPATH
        unset _OLD_VIRTUAL_PYTHONPATH
    elif [ -n "${_OLD_VIRTUAL_PYTHONPATH-}" ] ; then
        PYTHONPATH="$_OLD_VIRTUAL_PYTHONPATH"
        export PYTHONPATH
        unset _OLD_VIRTUAL_PYTHONPATH
    fi

    if [ "${_OLD_VIRTUAL_LHAPATH-}" = "Unset" ] ; then
        unset LHAPATH
        unset _OLD_VIRTUAL_LHAPATH
    elif [ -n "${_OLD_VIRTUAL_LHAPATH-}" ] ; then
        LHAPATH="$_OLD_VIRTUAL_LHAPATH"
        export LHAPATH
        unset _OLD_VIRTUAL_LHAPATH
    fi

    if [ "${_OLD_VIRTUAL_@{ld_env_name}-}" = "Unset" ] ; then
        unset @{ld_env_name}
        unset _OLD_VIRTUAL_@{ld_env_name}
    elif [ -n "${_OLD_VIRTUAL_@{ld_env_name}-}" ] ; then
        @{ld_env_name}="$_OLD_VIRTUAL_@{ld_env_name}"
        export @{ld_env_name}
        unset _OLD_VIRTUAL_@{ld_env_name}
    fi

    if [ "${_OLD_VIRTUAL_CC-}" = "Unset" ] ; then
        unset CC
        unset _OLD_VIRTUAL_CC
    elif [ -n "${_OLD_VIRTUAL_CC-}" ] ; then
        CC="$_OLD_VIRTUAL_CC"
        export CC
        unset _OLD_VIRTUAL_CC
    fi

    if [ "${_OLD_VIRTUAL_CXX-}" = "Unset" ] ; then
        unset CXX
        unset _OLD_VIRTUAL_CXX
    elif [ -n "${_OLD_VIRTUAL_CXX-}" ] ; then
        CXX="$_OLD_VIRTUAL_CXX"
        export CXX
        unset _OLD_VIRTUAL_CXX
    fi

    if [ "${_OLD_VIRTUAL_FC-}" = "Unset" ] ; then
        unset FC
        unset _OLD_VIRTUAL_FC
    elif [ -n "${_OLD_VIRTUAL_FC-}" ] ; then
        FC="$_OLD_VIRTUAL_FC"
        export FC
        unset _OLD_VIRTUAL_FC
    fi

    if [ "${_OLD_VIRTUAL_F77-}" = "Unset" ] ; then
        unset F77
        unset _OLD_VIRTUAL_F77
    elif [ -n "${_OLD_VIRTUAL_F77-}" ] ; then
        F77="$_OLD_VIRTUAL_F77"
        export F77
        unset _OLD_VIRTUAL_F77
    fi

    # This should detect bash and zsh, which have a hash command that must
    # be called to get it to forget past commands.  Without forgetting
    # past commands the $PATH changes we made may not be respected
    if [ -n "${BASH-}" -o -n "${ZSH_VERSION-}" ] ; then
        hash -r 2>/dev/null
    fi

    if [ -n "${_OLD_VIRTUAL_PS1-}" ] ; then
        PS1="$_OLD_VIRTUAL_PS1"
        export PS1
        unset _OLD_VIRTUAL_PS1
    fi

    unset TEXMFHOME
    unset HOMETEXMF
    unset TEXMFCNF
    unset TEXINPUTS
    unset LATEXINPUTS
    unset HERWIG_ENV
    if [ ! "${1-}" = "nondestructive" ] ; then
    # Self destruct!
        unset -f deactivate
    fi
}

# unset irrelevant variables
deactivate nondestructive

HERWIG_ENV="@{base_dir}"
export HERWIG_ENV

# adding the path to rivet latex required packages
export TEXMFHOME="${HERWIG_ENV}/share/Rivet/texmf:$TEXMFHOME"
export HOMETEXMF="${HERWIG_ENV}/share/Rivet/texmf:$HOMETEXMF"
export TEXMFCNF="${HERWIG_ENV}/share/Rivet/texmf/cnf:$TEXMFCNF"
export TEXINPUTS="${HERWIG_ENV}/share/Rivet/texmf/tex//:$TEXINPUTS"
export LATEXINPUTS="${HERWIG_ENV}/share/Rivet/texmf/tex//:$LATEXINPUTS"

_OLD_VIRTUAL_PATH="${PATH-Unset}"
PATH="@{bin_dir}:$PATH"
export PATH

_OLD_VIRTUAL_PYTHONPATH="${PYTHONPATH-Unset}"
PYTHONPATH="@{python_path}:$PYTHONPATH"
export PYTHONPATH

_OLD_VIRTUAL_LHAPATH="${LHAPATH-Unset}"
LHAPATH="@{lha_path}:$LHAPATH"
export LHAPATH

_OLD_VIRTUAL_@{ld_env_name}="${@{ld_env_name}-Unset}"
@{ld_env_name}="@{lib_dirs}:$@{ld_env_name}"
export @{ld_env_name}

_OLD_VIRTUAL_CC="${CC-Unset}"
CC="@{default_cc}"
export CC

_OLD_VIRTUAL_CXX="${CXX-Unset}"
CXX="@{default_cxx}"
export CXX

_OLD_VIRTUAL_FC="${FC-Unset}"
FC="@{default_fc}"
export FC

_OLD_VIRTUAL_F77="${F77-Unset}"
F77="@{default_fc}"
export F77

if [ -z "${HERWIG_ENV_DISABLE_PROMPT-}" ] ; then
    _OLD_VIRTUAL_PS1="$PS1"
    if [ "x" != x ] ; then
        PS1="$PS1"
    else
        PS1="(`basename \"$HERWIG_ENV\"`)$PS1"
    fi
    export PS1
fi

# This should detect bash and zsh, which have a hash command that must
# be called to get it to forget past commands.  Without forgetting
# past commands the $PATH changes we made may not be respected
if [ -n "${BASH-}" -o -n "${ZSH_VERSION-}" ] ; then
    hash -r 2>/dev/null
fi

""")

subs = {
    'ld_env_name' : ld_env_name,
    'bin_dir' : bin_dir,
    'base_dir' : base_dir,
    'python_path' : python_path,
    'lib_dirs' : lib_dirs,
    'default_cc' : os.path.basename(default_cc),
    'default_cxx' : os.path.basename(default_cxx),
    'default_fc' : os.path.basename(default_fc),
    'lha_path' : os.path.join(base_dir,'share','LHAPDF')
}

activate_file = os.path.join(bin_dir,'activate')
#activate_file = "/home/pratixan/Work_Dir/MAP/Herwig+P8I/Herwig-7.3_test/bin/activate"

with open(activate_file,'w') as f:
    f.write(ACTIVATE.substitute(subs))


# back to the original directory
os.chdir(current_dir)

try:
    path_to_activate = os.path.join(os.path.relpath(bin_dir,current_dir),'activate')
except:
    path_to_activate = activate_file

print ("""
################ /  / ^^/ ##########################
############### /--/   / ###########################
############## /  /   / ############################

 Herwig 7 bootstrap was successful.

 $ source %s

     activates all required environment variables.

 $ deactivate

     returns to the original environment variables.
""" % path_to_activate)
